* The expected host/host-collection-oriented API can probably be effected via
  invoke.Context subclasses - since that's exactly what they are (contexts for
  execution) and Context would provide an existing API for the same shit (like
  .run; settings/configuration crap; etc).
* sudo() and local() should probably be implemented as a 'via' kwarg on
  ctx.run?
    * How to handle the 'run locally or remotely, intelligently' feature
      request? I think just by having the class itself be smart about it? I.e.
      if you're "running on localhost" that implies the Context would be the
      Invoke default, or some other obviously-not-ssh-related class
      implementing a local runner.
        * I guess ambiguity would still exist if you're not using the
          context-based API - but that should probably not be allowed in Fab
          itself because it just doesn't fly. You'd be explicitly using
          invoke.run there? There would be no 'from fabric import run'.
    * Does not solve the situation where one's 'host' is literally 'localhost'
      (versus being unspecified/blank as in Fab 1 ) but I don't think that was
      the common case - the common case was running a task function with no
      host list.


## Context managers

General implementation: these methods on Context (or Connection, etc) spawn a
new object which is basically a callback of sorts - it's given a link to the
context, the argument(s) given to the method (e.g. the path to cd to; the
settings to change; etc) and some way of altering that context on both
__enter__ and __exit__.

The "obvious" way of doing the latter is:

* pass an attribute name + a mutator function to this new object
* it then backs up, to itself, the current value at time of __enter__,
  replacing it with the mutated value
* in __exit__ it updates the parent with the older, preserved attribute value.

Could alter this slightly by having the mutator functions (lamdas) implemented
as other methods on Context and pass their name to the sub-object. However, the
sub-object would still need the attribute info so it could perform backup; and
restoration would then require setters which just feels silly.

### cd, lcd

As now, implemented with a list of paths that gets join'd on use.

May want to rename cd() to rcd() - people continue to be confused by cd() and
assume it applies locally.

lcd() should be something implemented in Invoke (and stands to reason cd()
would also - just w/ different target setting names so they remain distinct.)

### hide, show

Assuming hiding/showing is implemented similar to fab 1 (BIG assumption) - same
as cd, just tickles context state.

Should really be handled by Invoke, eh? And ideally log-based in some fashion.

May want to split things up:

* stdout/err, due to being stream based, are simply local defaults for run()'s
  kwargs. So these might just become regular settings and not deserving of
  their own contextmanager methods?
* Everything else are local line-based output levels and would thus just fit
  well into a real logging framework. So would need to implement that in a way
  that fits w/ the logging setup. So that might also be slightly different and
  live under a single, non-hide/show set of methods (tho possibly still context
  manager?)

tl;dr do we even want contextmanagers for this? They started out as the ONLY
way to hide things, but now that the API can do it per-run(), it may not make a
ton of sense.

### path, prefix

These should also be more generic and Invoke-ish since they can apply to
command running in general. But probably remain lists under the hood.

### remote_tunnel

Spawns new channels & sockets to handle the port forwards, tracks those in apparently-global state within fabric.contextmanagers (i.e. just inside the function itself? not sure why that works, the body should rerun every time the context manager is used) and hands a ThreadHandler to Paramiko which actually spins it up to forward ports.

So, probably needs a decently sized rewrite to be clean n such; only real Fab stuff it uses is the connection dict / env.host_string.

### settings

Likely replaced by whatever settings API is exposed in Context. Maybe try to get a sense of what settings folks frequently use it for now, besides nesting hide/show + warn_only + host_string. Suspect that would be bulk of it?

Then again the ability to run with temporarily different context for arbitrary stuff is handy. Meh.

### shell_env

Tracks a dict in Context, same as lcd/cd would with their lists? Once again, can probably roll into regular settings-y things.

### warn_only

Same as hide/show re: stdout/err - might not _need_ to be contextmanager anymore, just given as per-run() kwarg or tickled in Context settings junk.
